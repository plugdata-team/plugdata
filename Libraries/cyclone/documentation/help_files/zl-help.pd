#N canvas 481 56 558 571 10;
#X obj 2 251 cnv 3 550 3 empty empty inlets 8 12 0 13 #dcdcdc #000000 0;
#X obj 2 369 cnv 3 550 3 empty empty outlets 8 12 0 13 #dcdcdc #000000 0;
#X obj 82 258 cnv 17 3 84 empty empty 0 5 9 0 16 #dcdcdc #9c9c9c 0;
#X obj 82 377 cnv 17 3 17 empty empty 0 5 9 0 16 #dcdcdc #9c9c9c 0;
#X obj 82 347 cnv 17 3 17 empty empty 1 5 9 0 16 #dcdcdc #9c9c9c 0;
#X obj 82 398 cnv 17 3 17 empty empty 1 5 9 0 16 #dcdcdc #9c9c9c 0;
#X obj 159 222 nbx 2 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10 #dcdcdc #000000 #000000 0 256;
#X obj 159 198 cyclone/zl len;
#X text 119 271 anything;
#X text 178 271 - one or more element messages to be processed;
#X text 119 346 anything;
#X text 119 397 anything;
#X text 119 376 anything;
#X text 91 328 zlmaxsize <f>;
#X obj 2 421 cnv 3 550 3 empty empty arguments 8 12 0 13 #dcdcdc #000000 0;
#X obj 2 544 cnv 15 552 21 empty empty empty 20 12 0 14 #e0e0e0 #202020 0;
#X text 170 443 -;
#X text 170 427 -;
#X text 112 427 1) float;
#X text 112 443 1) symbol;
#X obj 2 517 cnv 3 550 3 empty empty attributes 8 12 0 13 #dcdcdc #000000 0;
#X msg 202 145 beep 1 2 3 4;
#X text 143 256 bang;
#X text 126 313 zlclear;
#N canvas 452 109 635 453 examples 0;
#X obj 54 228 bng 18 250 50 0 empty empty empty 0 -6 0 8 #d0d0d0 #404040 #000000;
#X obj 157 348 nbx 4 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10 #dcdcdc #000000 #000000 0 256;
#N canvas 740 59 394 428 ecils 0;
#X obj 235 277 nbx 3 14 0 100 0 0 empty empty empty 0 -8 0 10 #dcdcdc #000000 #000000 0 256;
#X text 275 275 split point;
#X text 32 379 See also 'slice' mode;
#X obj 59 264 bng 20 250 50 0 empty empty empty 17 7 0 10 #dcdcdc #000000 #000000;
#X obj 112 338 print ecils_Left;
#X obj 235 339 print ecils_Right;
#X msg 122 268 a b c d e f g h;
#X msg 112 243 1 2 3 4 5 6 7;
#X msg 90 216 mode ecils 4;
#X text 21 28 'ecils' is 'slice' backwards \, so it slices a list in reverse order. You can set the split point with an argument or with a float input into the right inlet \, but also when you set the mode with the mode message. The default point is '0' \, which means no slicing.;
#X text 24 154 A bang performs the operation in the last received list.;
#X text 22 104 If you slice at 'n' \, the left outlet spits the last 'n' elements and the right outlet sends the first sliced elements.;
#X text 172 215 <= sets mode and argument;
#X msg 56 189 zlclear;
#X obj 112 301 cyclone/zl.ecils 3, f 21;
#X connect 0 0 14 1;
#X connect 3 0 14 0;
#X connect 6 0 14 0;
#X connect 7 0 14 0;
#X connect 8 0 14 0;
#X connect 13 0 14 0;
#X connect 14 0 4 0;
#X connect 14 1 5 0;
#X restore 441 123 pd ecils;
#N canvas 864 197 407 464 group 0;
#X obj 273 251 bng 25 250 50 0 empty empty empty 17 7 0 10 #dcdcdc #000000 #000000;
#X obj 266 352 nbx 3 14 1 10 0 0 empty empty empty 0 -8 0 10 #dcdcdc #000000 #000000 0 256;
#X text 306 350 group size;
#X floatatom 190 329 5 0 0 0 - - - 0;
#X text 30 335 remainder;
#X obj 273 285 cyclone/uzi 24;
#X text 15 207 The right outlet is inactive.;
#X obj 155 408 print zl_group;
#X msg 155 246 mode group 4;
#X text 33 245 set mode & argument;
#X text 13 104 The input can have one or more elements \, when the grouped elements reach the group size \, the grouped list is sent out the left outlet. The remaining items are stored for next group.;
#X text 14 163 A bang message causes it to spit (and clear from the memory) the remaining stored elements (at the set group size).;
#X msg 97 276 zlclear;
#X text 14 23 The group mode aggroups 'n' elements into a list \, where 'n' cannot be higher than the maximum zl size. You can set 'n' (the group size) with an argument or with a float input into the right inlet \, but also when you set the mode with the mode message. The default group size is 0 \, which means nothing gets grouped and output.;
#X msg 177 303 list g h i j k;
#X msg 165 280 a b c d e f;
#X obj 155 375 cyclone/zl.group 10;
#X obj 94 329 bng 25 250 50 0 empty empty empty 17 7 0 10 #dcdcdc #000000 #000000;
#X connect 0 0 5 0;
#X connect 1 0 16 1;
#X connect 3 0 16 0;
#X connect 5 2 16 0;
#X connect 8 0 16 0;
#X connect 12 0 16 0;
#X connect 14 0 16 0;
#X connect 15 0 16 0;
#X connect 16 0 7 0;
#X connect 17 0 16 0;
#X restore 441 165 pd group;
#N canvas 753 249 463 451 iter 0;
#X msg 174 275 1 2 3 4 5 6;
#X msg 156 247 mode iter 4;
#X obj 156 381 print iter;
#X text 28 37 The iter mode breaks an input list in to successive lists of a given size. If an input list is smaller than the iter size \, the lista is output anyway - if the last bit of the broken list is of a size smaller than the iter size \, it is also output.;
#X obj 116 278 bng 18 250 50 0 empty empty empty 17 7 0 10 #dcdcdc #000000 #000000;
#X floatatom 199 324 5 0 0 0 - - - 0;
#X obj 255 331 nbx 3 14 1 100 0 0 empty empty empty 0 -8 0 10 #dcdcdc #000000 #000000 0 256;
#X text 295 329 iter size;
#X text 28 109 The iter size can be set with an argument or with a float input into the right inlet \, but also when you set the mode with the mode message. The minimum iter size is 1 and the default is '0' \, which means nothing happens.;
#X text 29 190 The right outlet is inactive.;
#X msg 185 300 one two three four five six;
#X text 29 170 A bang performs the operation in the last received list.;
#X text 234 246 <= sets mode and argument;
#X msg 132 224 zlclear;
#X obj 156 356 cyclone/zl.iter 1;
#X connect 0 0 14 0;
#X connect 1 0 14 0;
#X connect 4 0 14 0;
#X connect 5 0 14 0;
#X connect 6 0 14 1;
#X connect 10 0 14 0;
#X connect 13 0 14 0;
#X connect 14 0 2 0;
#X restore 441 206 pd iter;
#N canvas 788 131 408 292 join 0;
#X obj 141 240 print zl_join;
#X obj 77 151 bng 18 250 50 0 empty empty empty 0 -6 0 8 #d0d0d0 #404040 #000000;
#X text 25 150 resends;
#X msg 122 139 mode join a b;
#X text 16 36 The join mode joins two lists sent to each inlet (things in list 2 that are in list 1 are duplicated). A bang resends the last output or outputs a new list if the right inlet received something new. Subsequent arguments initialize the right list. The right outlet is inactive.;
#X msg 264 168 x y z;
#X msg 141 167 1 2 3;
#X text 208 138 <= sets mode and arguments;
#X msg 97 113 zlclear;
#X obj 141 207 cyclone/zl.join 4 5 6;
#X connect 1 0 9 0;
#X connect 3 0 9 0;
#X connect 5 0 9 1;
#X connect 6 0 9 0;
#X connect 8 0 9 0;
#X connect 9 0 0 0;
#X restore 441 227 pd join;
#N canvas 781 151 405 407 len 0;
#X msg 162 176 this produces 3;
#X msg 173 208 and this should be five;
#X msg 138 145 list two elements;
#X obj 138 311 nbx 4 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10 #dcdcdc #000000 #000000 0 256;
#X obj 79 211 bng 18 250 50 0 empty empty empty 17 7 0 10 #dcdcdc #000000 #000000;
#X obj 138 339 print zl_len;
#X msg 113 116 mode len;
#X msg 183 241 1 2 3 4 5 6 7 8 9 10 11 12 13 14;
#X text 171 115 <= sets mode;
#X text 28 211 resends;
#X text 31 32 The len mode outputs how many elements a lista has. A bang resends the last output. This mode has no arguments. The right inlet/outlet are inactive.;
#X msg 91 92 zlclear;
#X obj 138 275 cyclone/zl.len;
#X connect 0 0 12 0;
#X connect 1 0 12 0;
#X connect 2 0 12 0;
#X connect 3 0 5 0;
#X connect 4 0 12 0;
#X connect 6 0 12 0;
#X connect 7 0 12 0;
#X connect 11 0 12 0;
#X connect 12 0 3 0;
#X restore 441 270 pd len;
#N canvas 573 172 789 398 mth 0;
#X obj 70 266 bng 18 250 50 0 empty empty empty 0 -6 0 8 #d0d0d0 #404040 #000000;
#X obj 451 220 bng 18 250 50 0 empty empty empty 0 -6 0 8 #d0d0d0 #404040 #000000;
#X msg 117 259 1 2 3 4 5 6 7 8 9 10;
#X obj 210 293 nbx 3 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10 #dcdcdc #000000 #000000 0 256;
#X obj 72 358 nbx 3 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10 #dcdcdc #000000 #000000 0 256;
#X text 25 162 A bang performs the operation in the last received list.;
#X msg 504 200 1 2 3 4 5 6 7 8 9 10;
#X obj 440 301 nbx 3 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10 #dcdcdc #000000 #000000 0 256;
#X text 421 72 The element that replaces the mth element in the right outlet is set as the 2nd argument. This is optional \, no second argument (the default) does not replace the mth element by anything.;
#X obj 595 300 print replaced_mth;
#X text 638 229 mth / replacement;
#X text 250 292 mth;
#X obj 210 355 print not_the_mth;
#X msg 484 172 mode mth 3 hello;
#X msg 595 229 6 bye;
#X text 24 100 The mth element is set as the 1st argument. The 1st element is treated as "0 '(the default). If you set the mth to a number greater than the input list \, all the elements are sent to the right outlet \, the same happens for negative mth values.;
#X msg 103 232 mode mth 5;
#X msg 77 205 zlclear;
#X msg 462 145 zlclear;
#X obj 117 355 print zl_mth;
#X obj 484 300 print zl_mth;
#X text 24 36 The mode mth is the same as nth but starts counting from 0 isntead. It outputs the mth element of a message through the left outlet. The right outlet outputs the remaining elements \, but the output can also replace the mth element by another.;
#X obj 117 321 cyclone/zl.mth 3;
#X obj 484 264 cyclone/zl.mth 2 hi;
#X connect 0 0 22 0;
#X connect 1 0 23 0;
#X connect 2 0 22 0;
#X connect 3 0 22 1;
#X connect 6 0 23 0;
#X connect 13 0 23 0;
#X connect 14 0 23 1;
#X connect 16 0 22 0;
#X connect 17 0 22 0;
#X connect 18 0 23 0;
#X connect 22 0 4 0;
#X connect 22 0 19 0;
#X connect 22 1 12 0;
#X connect 23 0 7 0;
#X connect 23 0 20 0;
#X connect 23 1 9 0;
#X restore 441 337 pd mth;
#N canvas 426 244 812 412 nth 0;
#X obj 76 265 bng 18 250 50 0 empty empty empty 0 -6 0 8 #d0d0d0 #404040 #000000;
#X obj 467 188 bng 18 250 50 0 empty empty empty 0 -6 0 8 #d0d0d0 #404040 #000000;
#X msg 128 257 1 2 3 4 5 6 7 8 9 10;
#X obj 221 291 nbx 3 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10 #dcdcdc #000000 #000000 0 256;
#X text 261 290 nth;
#X obj 83 356 nbx 3 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10 #dcdcdc #000000 #000000 0 256;
#X text 26 156 A bang performs the operation in the last received list.;
#X obj 221 353 print not_the_nth;
#X obj 616 271 print replaced_nth;
#X msg 525 171 1 2 3 4 5 6 7 8 9 10;
#X text 422 46 The element that replaces the nth element in the right outlet is set as the 2nd argument. This is optional \, no second argument (the default) does not replace the nth element by anything.;
#X obj 461 272 nbx 3 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10 #dcdcdc #000000 #000000 0 256;
#X text 655 200 nth / replacement;
#X msg 505 143 mode nth 3 hello;
#X text 25 27 The mode nth is the same as mth but starts counting from 1 isntead. It outputs the nth element of a message through the left outlet. The right outlet outputs the remaining elements \, but the output can also replace the nth element by another., f 61;
#X text 24 94 The nth element is set as the 1st argument. The 1st element is treated as "1" \, if you set it as 0 (the default) or to a number greater than the input list \, all the elements are sent to the right outlet and nothing is sent via the left outlet., f 61;
#X text 186 225 <= sets mode and arguments;
#X msg 110 226 mode nth 8;
#X msg 616 200 0 bye;
#X msg 87 198 zlclear;
#X msg 483 118 zlclear;
#X obj 505 271 print zl_nth;
#X obj 128 353 print zl_nth;
#X obj 128 319 cyclone/zl.nth 3;
#X obj 505 235 cyclone/zl.nth 2 hi;
#X connect 0 0 23 0;
#X connect 1 0 24 0;
#X connect 2 0 23 0;
#X connect 3 0 23 1;
#X connect 9 0 24 0;
#X connect 13 0 24 0;
#X connect 17 0 23 0;
#X connect 18 0 24 1;
#X connect 19 0 23 0;
#X connect 20 0 24 0;
#X connect 23 0 5 0;
#X connect 23 0 22 0;
#X connect 23 1 7 0;
#X connect 24 0 11 0;
#X connect 24 0 21 0;
#X connect 24 1 8 0;
#X restore 441 358 pd nth;
#N canvas 786 294 430 326 reg 0;
#X obj 69 286 print reg;
#X obj 111 222 bng 18 250 50 0 empty empty empty 0 -6 0 8 #d0d0d0 #404040 #000000;
#X msg 306 192 this is stored;
#X msg 91 193 this is stored and sent;
#X msg 69 161 1 2 3 4;
#X msg 287 161 5 6 7 8;
#X text 136 224 <= outputs stored list;
#X msg 52 136 mode reg one two;
#X text 159 135 <= sets mode and arguments;
#X text 30 44 The reg mode stores lists. The initially stored list is set as an argument and changed in the right inlet. The left inlet stores and outputs the list. A bang sends the last stored list. The right outlet is inactive.;
#X msg 30 114 zlclear;
#X obj 69 251 cyclone/zl.reg initially stored elements;
#X connect 1 0 11 0;
#X connect 2 0 11 1;
#X connect 3 0 11 0;
#X connect 4 0 11 0;
#X connect 5 0 11 1;
#X connect 7 0 11 0;
#X connect 10 0 11 0;
#X connect 11 0 0 0;
#X restore 524 81 pd reg;
#N canvas 865 220 418 288 rev 0;
#X msg 137 155 way this something means this;
#X obj 80 159 bng 18 250 50 0 empty empty empty 17 7 0 10 #dcdcdc #000000 #000000;
#X text 25 38 The rev mode reverses the elements of a list. A bang resends the last output. This mode has no arguments. The right inlet/outlet are inactive.;
#X msg 148 182 1 2 3 4 5 6 7 8 9 10;
#X obj 117 252 print zl_rev;
#X msg 117 120 mode rev;
#X text 178 119 <= sets mode;
#X msg 94 91 zlclear;
#X obj 117 217 cyclone/zl.rev;
#X connect 0 0 8 0;
#X connect 1 0 8 0;
#X connect 3 0 8 0;
#X connect 5 0 8 0;
#X connect 7 0 8 0;
#X connect 8 0 4 0;
#X restore 524 102 pd rev;
#N canvas 842 204 399 436 rot 0;
#X msg 122 256 sometimes my grammar is all messed up;
#X obj 195 319 nbx 3 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10 #dcdcdc #000000 #000000 0 256;
#X obj 63 299 bng 18 250 50 0 empty empty empty 17 7 0 10 #dcdcdc #000000 #000000;
#X text 17 144 A bang performs the operation in the last received list.;
#X text 17 164 The right outlet is inactive.;
#X obj 102 383 print zl_rot;
#X text 16 23 The mode rot does rotate a list. If the rotation point is a positive number 'n' \, the list is shifted to the right by 'n' positions \, and the last 'n' elements are placed at the list start. If 'n' is negative \, the rotation happens at the other direction.;
#X text 17 87 You can set the rotation point with an argument or with a float input into the right inlet \, but also when you set the mode with the mode message. The default point is '0' \, which means no rotation.;
#X msg 146 286 1 2 3 4 5 6 7 8 9 10 11 12;
#X msg 102 227 mode rot -3;
#X text 179 227 <= sets mode and argument;
#X msg 77 200 zlclear;
#X obj 102 344 cyclone/zl.rot 3;
#X connect 0 0 12 0;
#X connect 1 0 12 1;
#X connect 2 0 12 0;
#X connect 8 0 12 0;
#X connect 9 0 12 0;
#X connect 11 0 12 0;
#X connect 12 0 5 0;
#X restore 524 123 pd rot;
#N canvas 942 241 424 357 sect 0;
#X obj 53 217 bng 18 250 50 0 empty empty empty 0 -6 0 8 #d0d0d0 #404040 #000000;
#X obj 230 302 bng 18 250 50 0 empty empty empty 0 -6 0 8 #d0d0d0 #404040 #000000;
#X text 245 318 no common elements;
#X text 251 304 bang if there are;
#X obj 89 303 print zl_sect;
#X msg 230 214 1 5 10 15 20;
#X msg 89 188 mode sect 3 6 9;
#X text 19 32 The mode sect outputs the elements of an input list that are in common to another list (set as an argument or via the right inlet). The default is an empty list.;
#X text 20 79 The right outlet outputs a bang if there are no matching elements.;
#X text 20 114 A bang performs the operation in the last received list into the left inlet.;
#X msg 97 243 1 2 3 4 5 6 7 8 9 10;
#X msg 250 240 0 100 1000;
#X text 189 188 <= sets mode and arguments;
#X msg 71 162 zlclear;
#X obj 89 271 cyclone/zl.sect 1 10 100;
#X connect 0 0 14 0;
#X connect 5 0 14 1;
#X connect 6 0 14 0;
#X connect 10 0 14 0;
#X connect 11 0 14 1;
#X connect 13 0 14 0;
#X connect 14 0 4 0;
#X connect 14 1 1 0;
#X restore 524 165 pd sect;
#N canvas 824 23 415 398 slice 0;
#X obj 236 259 nbx 3 14 0 100 0 0 empty empty empty 0 -8 0 10 #dcdcdc #000000 #000000 0 256;
#X text 276 257 split point;
#X obj 56 242 bng 20 250 50 0 empty empty empty 17 7 0 10 #dcdcdc #000000 #000000;
#X msg 123 250 a b c d e f g h;
#X msg 113 225 1 2 3 4 5 6 7;
#X text 25 136 A bang performs the operation in the last received list.;
#X text 33 361 See also 'ecils' mode;
#X text 22 30 The slice mode slices a list. You can set the split point with an argument or with a float input into the right inlet \, but also when you set the mode with the mode message. The default point is '0' \, which means no slicing.;
#X msg 92 198 mode slice 4;
#X obj 113 320 print slice_Left;
#X obj 236 321 print slice_Right;
#X text 23 96 If you slice at 'n' \, the left outlet spits the first 'n' elements and the right outlet sends the remaining elements.;
#X text 176 198 <= sets mode and argument;
#X msg 64 171 zlclear;
#X obj 113 283 cyclone/zl.slice 3, f 21;
#X connect 0 0 14 1;
#X connect 2 0 14 0;
#X connect 3 0 14 0;
#X connect 4 0 14 0;
#X connect 8 0 14 0;
#X connect 13 0 14 0;
#X connect 14 0 9 0;
#X connect 14 1 10 0;
#X restore 524 185 pd slice;
#N canvas 889 66 405 334 sub 0;
#X obj 69 188 bng 18 250 50 0 empty empty empty 0 -6 0 8 #d0d0d0 #404040 #000000;
#X msg 210 220 11;
#X msg 246 220 7 8 9;
#X msg 175 220 1;
#X obj 210 285 print occurrences;
#X obj 111 285 print position;
#X text 18 42 the sub mode searches for occurrences of the element(s) of the second list to the first list and outputs the number of occurrences in the right outlet and the position of such occurrences in the left outlet. If no occurrence is found \, the right outlet outputs 0 and nothing is output on the left outlet. Subsequent arguments initialize the right list.;
#X msg 111 161 mode sub 5;
#X text 182 161 <= sets mode and arguments;
#X msg 125 189 1 2 3 7 8 9 10 4 5 6 7 8 9 10;
#X msg 91 134 zlclear;
#X obj 111 251 cyclone/zl.sub 10;
#X connect 0 0 11 0;
#X connect 1 0 11 1;
#X connect 2 0 11 1;
#X connect 3 0 11 1;
#X connect 7 0 11 0;
#X connect 9 0 11 0;
#X connect 10 0 11 0;
#X connect 11 0 5 0;
#X connect 11 1 4 0;
#X restore 524 270 pd sub;
#N canvas 861 239 405 268 union 0;
#X obj 65 153 bng 18 250 50 0 empty empty empty 0 -6 0 8 #d0d0d0 #404040 #000000;
#X obj 108 227 print zl_union;
#X text 21 39 union the stuff in two lists (but does not duplicate things in list 2 that are in list 1). Subsequent arguments initialize the right list. The right outlet is inactive.;
#X msg 237 160 6.5 4 2.3 2 2 8 hi;
#X msg 108 127 mode union a b;
#X text 204 126 <= sets mode and arguments;
#X msg 83 96 zlclear;
#X msg 122 159 2.3 7 6.5 hi;
#X obj 108 198 cyclone/zl.union 10 20;
#X connect 0 0 8 0;
#X connect 3 0 8 1;
#X connect 4 0 8 0;
#X connect 6 0 8 0;
#X connect 7 0 8 0;
#X connect 8 0 1 0;
#X restore 525 359 pd union;
#X text 183 212 set to default;
#X obj 157 372 print length;
#X msg 157 256 zlmaxsize \$1;
#X msg 157 212 256;
#X msg 171 234 512;
#X text 197 234 back to 512;
#X obj 54 255 cyclone/uzi 512;
#N canvas 889 66 405 380 sort 0;
#X obj 69 212 bng 18 250 50 0 empty empty empty 0 -6 0 8 #d0d0d0 #404040 #000000;
#X text 192 185 <= sets mode and arguments;
#X msg 91 158 zlclear;
#X msg 233 244 1;
#X msg 198 244 -1;
#X msg 111 185 mode sort -1;
#X obj 111 309 print sorted;
#X obj 198 309 print indexes;
#X text 17 36 The sort mode sorts the elements of a list. An additional argument specifies the order: "-1" sorts in descending order \, and any other value sorts in ascending order (the default is "0"/ascending). This vis also specified in the right inlet.;
#X text 264 244 <= order;
#X text 18 98 The left outlet outputs the sorted list \, and the right outlet outputs the sorted indexes., f 57;
#X msg 125 214 10 3 b 4 6 a 9 d 2 c 1 5 0 8 7;
#X obj 111 275 cyclone/zl.sort;
#X connect 0 0 12 0;
#X connect 2 0 12 0;
#X connect 3 0 12 1;
#X connect 4 0 12 1;
#X connect 5 0 12 0;
#X connect 11 0 12 0;
#X connect 12 0 6 0;
#X connect 12 1 7 0;
#X restore 524 206 pd sort;
#N canvas 818 132 407 351 change 0;
#X obj 71 159 bng 18 250 50 0 empty empty empty 0 -6 0 8 #d0d0d0 #404040 #000000;
#X msg 89 102 zlclear;
#X msg 128 165 1 2 2 5.5 7 5 7 7 7;
#X obj 114 283 print zl_change;
#X obj 273 254 tgl 21 0 empty empty empty 17 7 0 10 #dcdcdc #000000 #000000 0 1;
#X obj 273 282 print changed;
#X msg 114 133 mode change;
#X text 190 133 <= sets mode;
#X obj 114 223 cyclone/zl.change a b e c e;
#X text 23 32 The change mode filters out list repetitions. The right outlet sends "1" when there's a new list and "0" when it is repeated. Arguments initialize the list to filter., f 56;
#X msg 151 195 list a b e c e;
#X connect 0 0 8 0;
#X connect 1 0 8 0;
#X connect 2 0 8 0;
#X connect 4 0 5 0;
#X connect 6 0 8 0;
#X connect 8 0 3 0;
#X connect 8 1 4 0;
#X connect 10 0 8 0;
#X restore 440 60 pd change;
#N canvas 861 239 403 352 compare 0;
#X obj 55 175 bng 18 250 50 0 empty empty empty 0 -6 0 8 #d0d0d0 #404040 #000000;
#X msg 73 108 zlclear;
#X msg 112 174 a b c;
#X msg 255 214 a b c d;
#X msg 123 202 a b c d;
#X msg 239 189 a b c;
#X msg 98 139 mode compare a b c;
#X text 220 138 <= sets mode and arguments;
#X text 21 41 The compare mode compares two lists and sends "1" if it is the same or "0" if it is not. In the case on non equal lists \, the right output sends the number of non equal indexes.;
#X obj 98 237 cyclone/zl.compare a b c;
#X obj 239 299 print indexes;
#X obj 98 299 print zl_compare;
#X obj 98 265 tgl 21 0 empty empty empty 0 -8 0 10 #dfdfdf #000000 #000000 0 1;
#X floatatom 239 269 5 0 0 0 - - - 0;
#X connect 0 0 9 0;
#X connect 1 0 9 0;
#X connect 2 0 9 0;
#X connect 3 0 9 1;
#X connect 4 0 9 0;
#X connect 5 0 9 1;
#X connect 6 0 9 0;
#X connect 9 0 12 0;
#X connect 9 1 13 0;
#X connect 12 0 11 0;
#X connect 13 0 10 0;
#X restore 440 81 pd compare;
#N canvas 861 239 390 258 delace 0;
#X obj 78 137 bng 18 250 50 0 empty empty empty 0 -6 0 8 #d0d0d0 #404040 #000000;
#X msg 96 80 zlclear;
#X obj 102 211 print zl_delace-A;
#X obj 219 211 print zl_delace-B;
#X msg 135 143 A 1 B 2 C 3;
#X msg 121 111 mode delace;
#X text 197 111 <= sets mode;
#X text 22 39 delace de-interleaves a list into two lists.;
#X obj 120 182 cyclone/zl.delace;
#X connect 0 0 8 0;
#X connect 1 0 8 0;
#X connect 4 0 8 0;
#X connect 5 0 8 0;
#X connect 8 0 2 0;
#X connect 8 1 3 0;
#X restore 440 102 pd delace;
#N canvas 713 142 405 306 filter 0;
#X obj 63 173 bng 18 250 50 0 empty empty empty 0 -6 0 8 #d0d0d0 #404040 #000000;
#X text 244 136 <= sets mode and arguments, f 14;
#X msg 81 106 zlclear;
#X msg 265 188 truc 1;
#X obj 106 267 print zl_filter;
#X msg 130 190 a b toto c titi;
#X obj 265 267 print indexes;
#X text 21 36 filter removes items in a list \, the items to filter are specified as the arguments or the right input. The right outlet outputs the unfiltered and output indexes.;
#X msg 106 136 mode filter toto titi;
#X msg 120 166 truc machin 2 3.4 1;
#X obj 106 218 cyclone/zl.filter toto titi;
#X listbox 265 243 17 0 0 0 - - - 0;
#X connect 0 0 10 0;
#X connect 2 0 10 0;
#X connect 3 0 10 1;
#X connect 5 0 10 0;
#X connect 8 0 10 0;
#X connect 9 0 10 0;
#X connect 10 0 4 0;
#X connect 10 1 11 0;
#X connect 11 0 6 0;
#X restore 441 144 pd filter;
#N canvas 783 223 405 268 lace 0;
#X obj 65 153 bng 18 250 50 0 empty empty empty 0 -6 0 8 #d0d0d0 #404040 #000000;
#X msg 83 96 zlclear;
#X text 223 126 <= sets mode;
#X msg 108 127 mode lace 1 2 3 4;
#X msg 122 159 A B C D;
#X obj 108 227 print zl_lace;
#X msg 243 167 10 20 30 40;
#X text 21 35 lace interleaves two lists. Subsequent arguments initialize the right list. The right outlet is inactive.;
#X obj 108 198 cyclone/zl.lace x w y z;
#X connect 0 0 8 0;
#X connect 1 0 8 0;
#X connect 3 0 8 0;
#X connect 4 0 8 0;
#X connect 6 0 8 1;
#X connect 8 0 5 0;
#X restore 441 248 pd lace;
#N canvas 827 198 405 268 lookup 0;
#X obj 65 153 bng 18 250 50 0 empty empty empty 0 -6 0 8 #d0d0d0 #404040 #000000;
#X obj 108 227 print zl_union;
#X text 224 127 <= sets mode and arguments;
#X msg 83 96 zlclear;
#X msg 297 170 a b 1 4;
#X msg 132 169 0 2;
#X msg 108 128 mode lookup x y z;
#X text 21 39 lookup outputs the nth elements in a list. The arguments or right input sets the list to lookup and the left input sets the nth elements.;
#X obj 108 199 cyclone/zl.lookup toto titi tutu;
#X connect 0 0 8 0;
#X connect 3 0 8 0;
#X connect 4 0 8 1;
#X connect 5 0 8 0;
#X connect 6 0 8 0;
#X connect 8 0 1 0;
#X restore 441 293 pd lookup;
#N canvas 861 239 405 301 median 0;
#X obj 111 145 bng 18 250 50 0 empty empty empty 0 -6 0 8 #d0d0d0 #404040 #000000;
#X msg 129 88 zlclear;
#X msg 168 151 1 2 2 5.5 7 5 7 7 7;
#X msg 188 175 6 1 3;
#X msg 154 119 mode median;
#X text 232 118 <= sets mode;
#X obj 154 229 nbx 4 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10 #dcdcdc #000000 #000000 0 256;
#X text 43 47 median outputs the median of a list of numbers;
#X obj 154 256 print zl_median;
#X obj 154 200 cyclone/zl.median;
#X connect 0 0 9 0;
#X connect 1 0 9 0;
#X connect 2 0 9 0;
#X connect 3 0 9 0;
#X connect 4 0 9 0;
#X connect 6 0 8 0;
#X connect 9 0 6 0;
#X restore 441 315 pd median;
#N canvas 861 239 441 293 scramble 0;
#X obj 34 160 bng 18 250 50 0 empty empty empty 0 -6 0 8 #d0d0d0 #404040 #000000;
#X msg 248 168 6.5 4 2.3 2 2 8 hi;
#X text 227 133 <= sets mode and arguments;
#X msg 52 103 zlclear;
#X msg 91 166 1 2 3.4 toto titi tutu;
#X obj 77 234 print zl_scramble;
#X obj 248 234 print indexes;
#X msg 77 134 mode scramble 1 2 3 4 5;
#X text 21 34 scramble scrambles the order of a list. The right input and arguments sets the list. The right outlet outputs the scrambled indexes.;
#X obj 77 205 cyclone/zl.scramble 1 2 3 4 5;
#X connect 0 0 9 0;
#X connect 1 0 9 1;
#X connect 3 0 9 0;
#X connect 4 0 9 0;
#X connect 7 0 9 0;
#X connect 9 0 5 0;
#X connect 9 1 6 0;
#X restore 524 144 pd scramble;
#N canvas 601 172 442 332 queue 0;
#X obj 117 181 bng 18 250 50 0 empty empty empty 0 -6 0 8 #d0d0d0 #404040 #000000;
#X msg 124 120 zlclear;
#X msg 164 174 1 a 2 b 3 c;
#X obj 257 272 nbx 3 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10 #dcdcdc #000000 #000000 0 256;
#X text 298 272 size;
#X msg 150 147 mode queue;
#X obj 192 205 nbx 3 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10 #dcdcdc #000000 #000000 0 256;
#X text 25 44 The queue mode is a FIFO message storage (First In \, First Out). A list input stores the elements sequenatially. A bang otuputs the stored elements in order. The right outlet outputs the size of the queue., f 63;
#X text 219 146 <= sets mode;
#X obj 164 270 print zl_queue;
#X obj 164 236 cyclone/zl.queue;
#X connect 0 0 10 0;
#X connect 1 0 10 0;
#X connect 2 0 10 0;
#X connect 5 0 10 0;
#X connect 6 0 10 0;
#X connect 10 0 9 0;
#X connect 10 1 3 0;
#X restore 524 60 pd queue;
#N canvas 573 172 443 327 stack 0;
#X obj 121 183 bng 18 250 50 0 empty empty empty 0 -6 0 8 #d0d0d0 #404040 #000000;
#X msg 128 122 zlclear;
#X msg 168 176 1 a 2 b 3 c;
#X obj 261 274 nbx 3 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10 #dcdcdc #000000 #000000 0 256;
#X text 302 274 size;
#X obj 196 207 nbx 3 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10 #dcdcdc #000000 #000000 0 256;
#X text 27 47 The stack mode is a LIFO message storage (Last In \, First Out). A list input stores the elements sequenatially. A bang otuputs the stored elements in order. The right outlet outputs the size of the queue., f 63;
#X msg 154 149 mode stack;
#X text 227 148 <= sets mode;
#X obj 168 272 print zl_stack;
#X obj 168 238 cyclone/zl.stack;
#X connect 0 0 10 0;
#X connect 1 0 10 0;
#X connect 2 0 10 0;
#X connect 5 0 10 0;
#X connect 7 0 10 0;
#X connect 10 0 9 0;
#X connect 10 1 3 0;
#X restore 524 227 pd stack;
#N canvas 840 133 464 326 stream 0;
#X obj 123 187 bng 18 250 50 0 empty empty empty 0 -6 0 8 #d0d0d0 #404040 #000000;
#X obj 281 214 nbx 3 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10 #dcdcdc #000000 #000000 0 256;
#X msg 130 126 zlclear;
#X obj 281 276 tgl 15 0 empty empty empty 17 7 0 10 #dcdcdc #000000 #000000 0 1;
#X msg 156 153 mode stream -5;
#X text 252 153 <= set mode/argument;
#X obj 190 204 nbx 3 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10 #dcdcdc #000000 #000000 0 256;
#X text 37 43 the stream mode makes a list with the last N items. The N is set as an argument or in the right inlet. A negative N inverts the list. The right outlet sends "1" if it reached the N number of elements and "0" otherwise. A bang resends the last output., f 62;
#X obj 170 276 print zl_stream;
#X obj 170 242 cyclone/zl.stream 5;
#X connect 0 0 9 0;
#X connect 1 0 9 1;
#X connect 2 0 9 0;
#X connect 4 0 9 0;
#X connect 6 0 9 0;
#X connect 9 0 8 0;
#X connect 9 1 3 0;
#X restore 524 248 pd stream;
#N canvas 804 199 422 308 sum 0;
#X obj 101 167 bng 18 250 50 0 empty empty empty 0 -6 0 8 #d0d0d0 #404040 #000000;
#X msg 148 160 1 2 3 4 5 6 7 8 9 10;
#X obj 148 256 nbx 3 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10 #dcdcdc #000000 #000000 0 256;
#X msg 108 106 zlclear;
#X msg 166 192 1 a 2 c;
#X msg 134 133 mode sum;
#X text 30 45 The mode sum sums the float values in a list \, symbol elements are ignored. A bang performs the operation in the last received list. Right inlet/outlet don't do anything.;
#X obj 148 222 cyclone/zl.sum;
#X connect 0 0 7 0;
#X connect 1 0 7 0;
#X connect 3 0 7 0;
#X connect 4 0 7 0;
#X connect 5 0 7 0;
#X connect 7 0 2 0;
#X restore 524 293 pd sum;
#N canvas 818 151 405 322 unique 0;
#X obj 74 175 bng 18 250 50 0 empty empty empty 0 -6 0 8 #d0d0d0 #404040 #000000;
#X text 259 138 <= sets mode and arguments, f 14;
#X msg 92 108 zlclear;
#X msg 276 211 truc 1;
#X msg 159 198 a b toto c titi;
#X text 32 38 unique removes items in a list \, the items to filter are specified as the arguments or the right input. The right outlet is inactive.;
#X msg 136 174 truc machin 2 3.4 1;
#X msg 117 138 mode unique toto titi;
#X obj 117 270 print zl_unique;
#X obj 117 241 cyclone/zl.unique toto titi;
#X connect 0 0 9 0;
#X connect 2 0 9 0;
#X connect 3 0 9 1;
#X connect 4 0 9 0;
#X connect 6 0 9 0;
#X connect 7 0 9 0;
#X connect 9 0 8 0;
#X restore 478 385 pd unique;
#N canvas 804 199 422 308 thin 0;
#X obj 101 167 bng 18 250 50 0 empty empty empty 0 -6 0 8 #d0d0d0 #404040 #000000;
#X msg 108 106 zlclear;
#X text 30 45 The thin mode remove all the duplicates from an input list. A bang performs the operation in the last received list. Right inlet/outlet don't do anything.;
#X msg 166 192 1 a 1 2 c 2;
#X msg 134 133 mode thin;
#X text 203 134 <= sets mode;
#X msg 148 160 a b e c e b b;
#X obj 148 250 print zl_thin;
#X obj 148 222 cyclone/zl.thin;
#X connect 0 0 8 0;
#X connect 1 0 8 0;
#X connect 3 0 8 0;
#X connect 4 0 8 0;
#X connect 6 0 8 0;
#X connect 8 0 7 0;
#X restore 525 337 pd thin;
#N canvas 700 167 435 325 indexmap 0;
#X obj 57 184 bng 18 250 50 0 empty empty empty 0 -6 0 8 #d0d0d0 #404040 #000000;
#X msg 64 133 zlclear;
#X msg 104 187 A B C D E F G H;
#X obj 104 273 print indexmap;
#X msg 251 208 0 0 1 0 3 2 5;
#X text 340 208 <= indexes;
#X text 33 35 In this mode \, a list of indexes (0-based) in the right inlet or as arguments indicates the indexes to generate a new list from the received list in the left inlet. An index less than 0 or greater than/equal to the number of elements of the incoming list will be clamped to 0 - a bang performs the operation in the last received list.;
#X msg 90 160 mode indexmap 4 5 3;
#X obj 104 239 cyclone/zl.indexmap 2 3 1;
#X connect 0 0 8 0;
#X connect 1 0 8 0;
#X connect 2 0 8 0;
#X connect 4 0 8 1;
#X connect 7 0 8 0;
#X connect 8 0 3 0;
#X restore 441 185 pd indexmap;
#N canvas 601 172 441 297 swap 0;
#X obj 101 150 bng 18 250 50 0 empty empty empty 0 -6 0 8 #d0d0d0 #404040 #000000;
#X msg 118 93 zlclear;
#X obj 144 233 print zl_swap;
#X msg 167 153 A B C D;
#X msg 144 120 mode swap 1 2 3 4;
#X msg 279 143 1 3 0 2;
#X msg 292 168 2 3;
#X text 35 35 The right inlet or argument is a list of pair of indexes (0-based) to swap in the received list in the left inlet. A bang performs the operation in the last received list., f 57;
#X text 332 142 <= indexes;
#X obj 144 199 cyclone/zl.swap 3 2 1 0;
#X connect 0 0 9 0;
#X connect 1 0 9 0;
#X connect 3 0 9 0;
#X connect 4 0 9 0;
#X connect 5 0 9 1;
#X connect 6 0 9 1;
#X connect 9 0 2 0;
#X restore 525 315 pd swap;
#X text 415 29 Examples:;
#X text 36 13 Basic:;
#X obj 167 293 cyclone/zl.group 512 @zlmaxsize 512;
#X text 38 400 In the above example \, the objects are initialized to a size of 512 but can be resized to the default (256)., f 54;
#X obj 157 321 cyclone/zl 512 len;
#X text 28 137 When not using a dot \, the mode argument is obrigatory \, otherwise an error is printed. This also implies there is no default mode. You can change mode as a message in any case \, by the way. Check details about each mode in the subpatches on the right., f 55;
#X text 28 37 The default maximum size is 256 elements. When you're not using a dot to set the mode \, you can change the maximum size with a first optional float argument. In this case you need a symbol argument that specifies the mode type. If you are using a dot you can only reset the maximum size with the '@zlmaxsize' attribute. The maximum size is also set via the 'zlmaxsize' attribute or message (and it can be up to 32767)., f 55;
#X connect 0 0 22 0;
#X connect 1 0 17 0;
#X connect 18 0 44 0;
#X connect 19 0 18 0;
#X connect 20 0 18 0;
#X connect 22 2 42 0;
#X connect 42 0 44 0;
#X connect 44 0 1 0;
#X restore 475 224 pd examples;
#X text 178 378 - output according to the mode: see details in [pd examples];
#X text 178 397 - output according to the mode: see details in [pd examples];
#X obj 126 144 bng 18 250 50 0 empty empty empty 17 7 0 10 #dcdcdc #000000 #000000;
#X msg 211 168 zlclear;
#X text 74 140 resends;
#X text 80 154 length;
#X text 178 346 - depends on the mode \, see [pd examples];
#N canvas 779 163 512 478 subsequent_arguments 0;
#X text 44 157 group;
#X text 50 189 iter;
#X text 56 255 mth;
#X text 56 285 reg;
#X text 50 332 sect;
#X text 44 347 slice;
#X text 56 300 rot;
#X text 44 125 ecils;
#X text 56 270 nth;
#X text 83 255 - float: the element position counting from 0 (default 0), f 65;
#X text 83 285 - anything: stored elements (default none), f 65;
#X text 56 394 sub;
#X text 83 394 - anything: elements to look for (default none), f 65;
#X text 83 157 - float: length of the grouped list (default is zlmaxsize), f 65;
#X text 83 270 - float: the element position counting from 1 (default 0), f 65;
#X text 83 300 - float: number to rotate to (default 0), f 65;
#X text 83 347 - float: position to slice the list (default 0), f 65;
#X text 83 125 - float: position to slice the list (default 0), f 65;
#X text 83 189 - float: length of output list (default 0), f 65;
#X text 44 427 union;
#X text 83 427 - anything: elements to union to the first list (default none), f 65;
#X text 50 205 join;
#X text 83 205 - anything: elements to join to the first list (default none), f 65;
#X text 50 363 sort;
#X text 83 363 - float: order "-1" is desending \, ascending otherwise (default 0), f 65;
#X text 32 110 compare;
#X text 83 332 - anything: list to compare with left input (default none), f 65;
#X text 83 110 - anything: list to compare with left input (default none), f 65;
#X text 38 141 filter;
#X text 50 222 lace;
#X text 38 239 lookup;
#X text 26 316 scramble;
#X text 83 316 - anything: list to be scrambled (default none), f 65;
#X text 83 222 - anything: 2nd list to be interleaved (default none), f 65;
#X text 83 239 - anything: list to be looked up (default none), f 65;
#X text 83 141 - anything: elements to filter (default none), f 65;
#X text 38 444 unique;
#X text 50 410 swap;
#X text 38 378 stream;
#X text 26 173 indexmap;
#X text 83 173 - anything: list to be remaped (default none), f 65;
#X text 83 378 - float: N elements to stream (default 0), f 65;
#X text 83 444 - anything: list of elements to "uniqued" (default none), f 65;
#X text 83 410 - anything: list to be swapped (default none), f 65;
#X text 38 95 change;
#X text 83 95 - anything: list to check if changed from left input (default none), f 67;
#X text 76 17 The modes: delace \, len \, median \, queue \, rev \, stack \, sum and thin don't have arguments. The other modes can have subsequent arguments as below. See also [pd examples] for more details on how they work., f 55;
#X restore 299 493 pd subsequent_arguments;
#X text 178 286 -;
#X text 190 285 sets mode (you can also set subsequent arguments) - check [pd examples] for more info;
#X text 178 328 - sets maximum list size (from 1 to 32767);
#X text 194 222 <= number of elements in a message;
#X text 253 198 length mode;
#X text 184 427 optional: maximum list size (1 - 32767 \, default 256), f 60;
#X text 129 524 @zlmaxsize <float> - max list size (1 - 32767 \, default 256), f 62;
#X text 178 313 - clears mode's arguments and received data in both inlets;
#X obj 159 146 nbx 2 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10 #dcdcdc #000000 #000000 0 256;
#X text 178 256 - mode dependent operation on current data see [pd examples];
#X text 262 168 clears loaded data;
#X obj 136 222 bng 15 250 50 0 empty empty empty 17 7 0 10 #dcdcdc #000000 #000000;
#X text 184 443 mode (change \, compare \, delace \, ecils \, group \, indexmap \, iter \, join \, lace \, len \, lookup \, median \, mth \, nth \, queue \, reg \, rev \, rot \, sect \, scramble \, slice \, sort \, stack \, stream \, sub \, sum \, swap \, thin \, union or unique). Modes can have subsequent arguments \, check:;
#X obj 3 3 ./header zl;
#X text 22 62 List processor;
#X text 36 85 [zl] processes messages with one or more elements ("list messages' or "anything") according to a mode set via argument/message or in the object name after a '.' (dot)., f 74;
#X obj 338 198 cyclone/zl.len;
#X text 107 285 mode <any>;
#X connect 7 0 6 0;
#X connect 7 0 44 0;
#X connect 21 0 7 0;
#X connect 27 0 7 0;
#X connect 28 0 7 0;
#X connect 41 0 7 0;

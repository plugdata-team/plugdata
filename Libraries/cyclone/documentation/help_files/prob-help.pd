#N canvas 676 41 558 578 10;
#X obj 2 328 cnv 3 550 3 empty empty inlets 8 12 0 13 #dcdcdc #000000 0;
#X obj 2 472 cnv 3 550 3 empty empty outlets 8 12 0 13 #dcdcdc #000000 0;
#X obj 2 524 cnv 3 550 3 empty empty arguments 8 12 0 13 #dcdcdc #000000 0;
#X obj 83 337 cnv 17 3 130 empty empty 0 5 9 0 16 #dcdcdc #9c9c9c 0;
#X obj 83 500 cnv 17 3 17 empty empty 1 5 9 0 16 #dcdcdc #9c9c9c 0;
#X obj 83 479 cnv 17 3 17 empty empty 0 5 9 0 16 #dcdcdc #9c9c9c 0;
#X text 189 530 (none);
#X msg 137 187 0 1 80 \, 0 2 20 \, 1 2 10 \, 1 0 90 \, 2 0 50 \, 2 1 50, f 16;
#X obj 36 217 metro 500;
#X obj 36 192 tgl 18 0 empty empty empty 17 7 0 10 #d0d0d0 #000000 #000000 0 1;
#X obj 137 248 cyclone/prob;
#C restore;
#X obj 137 299 hradio 15 1 0 3 empty empty empty 0 -8 0 10 #dcdcdc #000000 #000000 0;
#X obj 2 552 cnv 15 552 21 empty empty empty 20 12 0 14 #e0e0e0 #202020 0;
#X obj 137 159 loadbang;
#X text 144 480 float;
#X text 150 354 list;
#X text 150 500 bang;
#X obj 2 5 cnv 15 553 42 empty empty empty 20 12 0 14 #e0e0e0 #404040 0;
#N canvas 0 22 450 278 (subpatch) 0;
#X coords 0 1 100 -1 554 42 1 0 0;
#X restore 2 4 graph;
#X obj 305 5 cnv 15 250 40 empty empty empty 12 13 0 18 #7c7c7c #e0e4dc 0;
#N canvas 382 141 749 319 (subpatch) 0;
#X coords 0 -1 1 1 252 42 2 100 100;
#X restore 304 4 pd;
#X text 250 184 0 has 80% chance to go to 1 and 20% to go to 2 \;;
#X text 250 197 1 has 10% chance to go to 2 and 90% to go to 0 \;;
#X text 250 211 2 has a 50/50 chance to go to 1 and 0!;
#X text 73 89 [prob] outputs a weighted series of random numbers (1st order markov chain). It accepts lists of 3 numbers where the 3rd represents the weight/chance of going from value 1 to value 2 \, a bang will force [prob] to output. See below:;
#X text 181 480 - random number based on prob function;
#X text 181 500 - when we reach a number for which there is no rule;
#X text 181 354 - list of <value 1 \, value 2 \, weight>;
#X text 151 335 bang -;
#X text 145 401 clear - clears the probability matrix;
#X text 151 417 dump - print out all rule;
#X text 97 450 reset <float> -;
#N canvas 436 120 930 457 examples 0;
#X obj 80 222 bng 18 250 50 0 empty empty empty 17 7 0 10 #d0d0d0 #000000 #000000;
#X obj 181 301 bng 16 250 50 0 empty empty empty 0 -6 0 8 #d0d0d0 #000000 #000000;
#X text 44 22 When it receives a bang \, [prob] makes a random jump from its current state to another state based on its current weighting of transitions. If a transition can be made \, the new state is sent out the left outlet. If not \, a bang is sent out the right outlet., f 62;
#X msg 201 246 embed 1;
#X obj 112 168 loadbang;
#X obj 112 276 cyclone/prob;
#C restore;
#X msg 196 217 reset 1;
#X text 43 98 The matrix below just goes from 0 to 3 and has no rule for when it reaches 3 \, so it gets stuck. You can use the "reset" message to set a value for whenever [prob] gets stuck.;
#X text 254 246 store the current table;
#X text 236 265 when the patcher is saved *;
#X text 194 196 sets a value that prob goes back;
#X text 253 216 to when it gets stuck;
#X obj 112 302 nbx 2 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10 #dcdcdc #000000 #000000 0 256;
#X text 60 346 * embed <1> will set the [prob] object to store the probability matrix table within the patch when the patch is saved \, so the next time you open the patch it already has that table initialized - embed <0> (the default) disables it.;
#X msg 112 201 0 1 100 \, 1 2 100 \, 2 3 100, f 8;
#X obj 641 115 loadbang;
#X obj 641 195 cyclone/prob;
#C restore;
#X text 499 31 For any state \, the weights of all possible transition states are summed \, and the probability percentage is the weight value divided by that sum x 100 So \, if you have the messages "0 1 80" and "0 2 20" \, the sum is 100 and the percentage is 80% and 20%., f 62;
#X msg 641 140 0 1 3 \, 0 2 4 \, 0 0 1, f 7;
#X text 508 233 Below \, we have the weights 3 4 and 1 \, the sum is 8 and the first weight (3) represents a 37.5% chance \, the second (4) represents 50% and the third (1) represents 12.5%. Note that any state can make a transition to itself \, such as the last list above (0 0 1).;
#X obj 656 365 cyclone/anal;
#X obj 656 393 cyclone/prob;
#C restore;
#X text 510 331 The [anal] object was designed to feed [prob] \, check its help file.;
#X text 200 315 for which there is no rule;
#X text 200 300 <== when we reach a number;
#X text 36 214 choose state:, f 6;
#X connect 0 0 5 0;
#X connect 3 0 5 0;
#X connect 4 0 14 0;
#X connect 5 0 12 0;
#X connect 5 1 1 0;
#X connect 6 0 5 0;
#X connect 14 0 5 0;
#X connect 15 0 18 0;
#X connect 18 0 16 0;
#X connect 20 0 21 0;
#X restore 465 297 pd examples;
#X text 193 450 sets a value for when reaching a number with no rule;
#X msg 89 176 dump;
#X obj 80 289 print;
#X obj 137 276 nbx 2 15 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 12 #dcdcdc #000000 #000000 0 256;
#X text 97 433 embed <float> -;
#X text 192 433 <1> enables saving the matrix with the patch \, <0> disables;
#X text 217 248 <== click to view the probability matrix table;
#X obj 20 58 cyclone/comment 425 14 DejaVu\ Sans\ Mono empty 0 0 0 0 0 255 255 255 0 0 Probability matrix;
#X obj 16 5 cyclone/comment 425 33 DejaVu\ Sans\ Mono empty 0 0 0 0 0 255 255 255 0 0 prob;
#X obj 322 29 cyclone/comment 425 13 DejaVu\ Sans\ Mono empty 0 224 228 220 0 255 255 255 0 0 Objects cloned from Max/MSP;
#X obj 363 5 cyclone/comment 425 24 DejaVu\ Sans\ Mono empty 0 224 228 220 0 255 255 255 0 0 cyclone;
#X text 144 374 float;
#X text 181 374 -;
#X text 194 373 an integer sets (but doesn't output) the current number \, the next value depends on the probability matrix., f 56;
#X text 196 335 chooses a weighted random number;
#X text 240 263 (this is not present in the original object in MAX)., f 43;
#X connect 7 0 10 0;
#X connect 8 0 10 0;
#X connect 9 0 8 0;
#X connect 10 0 35 0;
#X connect 10 0 36 0;
#X connect 13 0 7 0;
#X connect 34 0 10 0;
#X connect 36 0 11 0;

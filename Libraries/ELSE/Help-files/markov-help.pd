#N canvas 437 23 563 662 10;
#X obj 169 182 bng 18 250 50 0 empty empty empty 17 7 0 10 #dcdcdc #000000 #000000;
#X msg 220 205 clear;
#X msg 199 183 create;
#X floatatom 262 256 5 0 0 0 - - - 0;
#X text 259 205 clear memory;
#X obj 3 335 cnv 3 550 3 empty empty inlets 8 12 0 13 #dcdcdc #000000 0;
#X obj 3 524 cnv 3 550 3 empty empty outlets 8 12 0 13 #dcdcdc #000000 0;
#X obj 3 589 cnv 3 550 3 empty empty arguments 8 12 0 13 #dcdcdc #000000 0;
#X obj 91 343 cnv 17 3 132 empty empty 0 5 9 0 16 #dcdcdc #9c9c9c 0;
#X obj 91 481 cnv 17 3 17 empty empty 1 5 9 0 16 #dcdcdc #9c9c9c 0;
#X obj 92 533 cnv 17 3 17 empty empty 0 5 9 0 16 #dcdcdc #9c9c9c 0;
#X obj 3 632 cnv 15 552 21 empty empty empty 20 12 0 14 #e0e0e0 #202020 0;
#X obj 5 5 cnv 15 301 42 empty empty markov 20 20 2 37 #e0e0e0 #000000 0;
#X obj 308 6 cnv 15 250 40 empty empty empty 12 13 0 18 #7c7c7c #e0e4dc 0;
#N canvas 0 22 450 278 (subpatch) 0;
#X coords 0 1 100 -1 302 42 1;
#X restore 4 5 graph;
#X obj 347 13 cnv 10 10 10 empty empty ELSE 0 15 2 30 #7c7c7c #e0e4dc 0;
#X obj 25 42 cnv 4 4 4 empty empty Create/play 0 28 2 18 #e0e0e0 #000000 0;
#X obj 462 13 cnv 10 10 10 empty empty EL 0 6 2 13 #7c7c7c #e0e4dc 0;
#X obj 482 13 cnv 10 10 10 empty empty Locus 0 6 2 13 #7c7c7c #e0e4dc 0;
#X obj 519 13 cnv 10 10 10 empty empty Solus' 0 6 2 13 #7c7c7c #e0e4dc 0;
#X obj 468 28 cnv 10 10 10 empty empty ELSE 0 6 2 13 #7c7c7c #e0e4dc 0;
#X obj 506 28 cnv 10 10 10 empty empty library 0 6 2 13 #7c7c7c #e0e4dc 0;
#N canvas 0 22 450 278 (subpatch) 0;
#X coords 0 1 100 -1 252 42 1 0 0;
#X restore 307 5 graph;
#X obj 180 42 cnv 4 4 4 empty empty chains 0 28 2 18 #e0e0e0 #000000 0;
#X obj 117 42 cnv 4 4 4 empty empty markov 0 28 2 18 #e0e0e0 #000000 0;
#X obj 91 501 cnv 17 3 17 empty empty 2 5 9 0 16 #dcdcdc #9c9c9c 0;
#X obj 199 303 else/display;
#X msg 230 230 60 \, 60 \, 62 \, 60 \, 65 \, 64;
#X text 299 255 set order;
#X text 182 341 bang;
#X text 219 341 - get value from markov chain and goes to the next;
#X text 170 355 create;
#X text 176 369 clear;
#X text 219 369 - clear memory, f 50;
#X text 219 355 - create markov chain from memory and go to start, f 50;
#X text 176 413 reset;
#X text 219 413 - go to the start of the chain, f 50;
#X text 170 427 random;
#X text 219 427 - go to a random position in the chain, f 50;
#X text 110 383 learn <anything>;
#X text 219 383 - feed memory with new information, f 50;
#X text 158 483 anything;
#X text 219 483 - feed memory with new information, f 50;
#X text 128 441 order <float>;
#X text 219 441 - sets order, f 50;
#X text 219 503 - sets order, f 50;
#X text 176 503 float;
#X text 147 534 anything;
#X text 210 534 - output from markov chain, f 32;
#X text 141 596 1) float - sets order (default 1);
#X text 141 612 2) float - non zero sets to savestate mode (default 0);
#N canvas 864 49 394 673 midi-file 0;
#X obj 49 254 stripnote;
#X msg 49 129 open;
#X msg 203 229 clear;
#X obj 253 223 tgl 18 0 empty empty empty 17 7 0 10 #dcdcdc #000000 #000000 0 1;
#X obj 67 179 trigger anything bang;
#X msg 67 153 dump;
#X obj 154 318 else/markov;
#X msg 154 229 create;
#X obj 49 229 else/note.in;
#X obj 52 372 else/keyboard 17 80 2 4 0 0 empty empty;
#X obj 154 343 makenote 127 300, f 22;
#X obj 108 546 *~;
#X obj 52 488 mtof;
#X obj 108 601 out~;
#X obj 52 514 else/tri~;
#X obj 123 514 else/adsr~ 50 10 0.7 100;
#X obj 108 574 else/plate.rev~ 50 0.6 0.25 0.8 0.5;
#X obj 52 463 unpack f f;
#X obj 49 205 else/midi bday.mid;
#X floatatom 244 295 3 1 5 0 - - - 0;
#X text 269 295 order;
#X msg 49 278 learn \$1;
#X obj 253 250 else/tempo 120 50;
#X obj 244 184 else/initmess 1;
#X text 32 14 This example creates a monophonic chain from MIDI input. Here you can also try to increase the order. An order of "2" means that the next note depends on the preceding two values. This makes it a lot less random \, so the more you increase the order \, the more it looks like the original input. After changing the order you need to recreate the chain. For this happy birthday example \, an order of 5 outputs the original tune., f 54;
#X text 100 153 <-- read/analyze;
#X text 84 128 <-- open another midi file;
#X text 274 223 <-- play;
#X connect 0 0 21 0;
#X connect 1 0 18 0;
#X connect 2 0 6 0;
#X connect 3 0 22 0;
#X connect 4 0 18 0;
#X connect 4 1 2 0;
#X connect 5 0 4 0;
#X connect 6 0 10 0;
#X connect 7 0 6 0;
#X connect 8 0 0 0;
#X connect 8 1 0 1;
#X connect 9 0 17 0;
#X connect 10 0 9 0;
#X connect 10 1 9 1;
#X connect 11 0 16 0;
#X connect 12 0 14 0;
#X connect 14 0 11 0;
#X connect 15 0 11 1;
#X connect 16 0 13 0;
#X connect 17 0 12 0;
#X connect 17 1 15 0;
#X connect 18 0 8 0;
#X connect 18 1 7 0;
#X connect 19 0 6 2;
#X connect 21 0 6 0;
#X connect 22 0 6 0;
#X connect 23 0 19 0;
#X restore 462 261 pd midi-file;
#N canvas 807 97 429 499 midi-in 0;
#X obj 173 103 stripnote;
#X msg 153 73 clear;
#X obj 26 25 tgl 18 0 empty empty empty 17 7 0 10 #dcdcdc #000000 #000000 0 1;
#X obj 142 177 else/markov;
#X msg 143 49 create;
#X obj 40 231 else/keyboard 17 80 2 4 0 0 empty empty;
#X obj 142 202 makenote 127 300, f 22;
#X text 47 25 <= play;
#X floatatom 205 155 5 0 0 0 - - - 0;
#X text 241 153 order;
#X obj 209 76 notein;
#X obj 173 130 else/combine 50;
#X text 272 130 <= create lists;
#X text 290 142 for chords;
#X obj 40 363 clone 4 voice 4;
#X obj 40 400 else/out~;
#X text 164 374 In this example you can use a MIDI keyboard to feed the [markov] object. With the [combine] object you can generate lists for chords., f 37;
#X text 255 75 <= MIDI input;
#X obj 26 49 else/tempo 120 50;
#X obj 40 334 else/voices -list 4 1;
#X connect 0 0 11 0;
#X connect 1 0 3 0;
#X connect 2 0 18 0;
#X connect 3 0 6 0;
#X connect 4 0 3 0;
#X connect 5 0 19 0;
#X connect 6 0 5 0;
#X connect 6 1 5 1;
#X connect 8 0 3 2;
#X connect 10 0 0 0;
#X connect 10 1 0 1;
#X connect 11 0 3 1;
#X connect 14 0 15 0;
#X connect 14 1 15 1;
#X connect 18 0 3 0;
#X connect 19 0 14 0;
#X restore 474 283 pd midi-in;
#X text 372 230 <-- 1) feed memory;
#X text 245 181 <-- 2) create markov chain and go to start;
#X text 95 183 3) Play -->;
#X text 48 91 [markov] creates Markov chains of any order out of progressions of floats \, symbols or lists (which can be used to create polyphonic chains). You can change the order and recreate the chain. You can keep feeding information after the chain was created and recreate with the new information. You can also clear the memory to restart from scratch. State saving is possible with the 2nd argument \, where the chain is saved with the patch., f 75;
#X obj 6 559 cnv 3 550 3 empty empty flags 8 12 0 13 #dcdcdc #000000 0;
#X text 130 568 -seed <float>: sets seed (default: unique internal), f 54;
#X text 219 457 - a float sets seed \, no float sets a unique internal;
#X text 134 456 seed <float>;
#N canvas 179 118 719 396 seed/savestate 0;
#X obj 334 76 bng 18 250 50 0 empty empty empty 17 7 0 10 #dcdcdc #000000 #000000;
#X obj 366 182 else/display;
#X msg 445 101 clear \, 60 \, 60 \, 62 \, 60 \, 65 \, 64 \, create;
#X obj 366 157 else/markov -seed 12345 1 1;
#A saved memory 60 ||| \; 62 ||| \; 65 ||| \; 64 ||| \;;
#A saved order 1;
#A saved markov 3 0 \; 0 0 1 2 \; 1 0 \; 2 3 \;;
#A saved indices 0 0 1 0 2 3;
#X obj 334 328 else/display;
#X msg 413 246 clear \, 60 \, 60 \, 62 \, 60 \, 65 \, 64 \, create;
#X obj 334 303 else/markov -seed 12345 1 1;
#A saved memory 60 ||| \; 62 ||| \; 65 ||| \; 64 ||| \;;
#A saved order 1;
#A saved markov 3 0 \; 0 0 1 2 \; 1 0 \; 2 3 \;;
#A saved indices 0 0 1 0 2 3;
#X obj 445 122 route float;
#X obj 413 267 route float;
#X msg 625 43 seed;
#X obj 607 69 s \$0-seed;
#X msg 607 20 seed 12345;
#X obj 366 115 r \$0-seed;
#X obj 346 265 r \$0-seed;
#X text 546 69 Set seed;
#X text 40 42 Pseudo random number generators aren't true random number generators. Instead \, an algorithm is used to provide a sequence of numbers that seems random. The same sequence can be reproduced if you set a "seed" value \, which can be any integer number., f 42;
#X text 42 217 You can set a seed with the '-seed' flag. If you don't supply it \, each object gets its own seed internal seed. If you send a 'seed' message without float \, the object also gets a unique seed value., f 42;
#X text 359 77 <-- Play;
#X text 40 130 Seeds are kept locally \, which means that if two [markov] objects are seeded the same they will have the same output. Conversely \, you can seed the same [markov] object twice with the same seed to repeat the output., f 42;
#X text 353 25 Sync [markov] objects fed with the same data objects with a seed value., f 37;
#X obj 366 212 print markov-A;
#X obj 334 363 print markov-B;
#X text 557 123 (recreate the chain);
#X text 42 284 The objects to the right were saved with the chain data because of the savestate 2nd argument \, which saves the markov chain with the patch when you save the file. You can also use the "savestate" message to set the object into "savestate" mode., f 42;
#X connect 0 0 3 0;
#X connect 0 0 6 0;
#X connect 1 0 20 0;
#X connect 2 0 7 0;
#X connect 3 0 1 0;
#X connect 4 0 21 0;
#X connect 5 0 8 0;
#X connect 6 0 4 0;
#X connect 7 0 3 1;
#X connect 7 1 3 0;
#X connect 8 0 6 1;
#X connect 8 1 6 0;
#X connect 9 0 10 0;
#X connect 11 0 10 0;
#X connect 12 0 3 0;
#X connect 13 0 6 0;
#X restore 432 305 pd seed/savestate;
#X obj 199 277 else/markov;
#X text 219 398 - feed memory with new information, f 50;
#X text 104 398 savestate <float>;
#X connect 0 0 62 0;
#X connect 1 0 62 0;
#X connect 2 0 62 0;
#X connect 3 0 62 2;
#X connect 27 0 62 1;
#X connect 62 0 26 0;

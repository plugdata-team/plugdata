#N canvas 589 86 490 518 12;
#X declare -path else;
#X obj 257 282 nbx 8 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10 #dcdcdc #000000 #000000 0 256;
#X obj 345 280 nbx 8 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10 #dcdcdc #000000 #000000 0 256;
#X obj 254 27 declare -path else;
#X obj 257 313 vsl 19 162 0 100 0 0 empty empty empty 0 -9 0 12 #dfdfdf #000000 #000000 0 1;
#X obj 257 208 adc~ 1;
#X obj 257 254 env~ 8192;
#X obj 345 253 rms~;
#X obj 57 278 *~;
#X obj 166 275 mov.rms~ 4096, f 9;
#X obj 166 329 meter~;
#X obj 57 238 bl.saw~ 50;
#X obj 57 322 out~;
#X text 36 64 We've already seen the [env~] object from Pd Vanilla and the [rms~] abstraction from ELSE that is based on it. The difference is just the output scale. They RMS amplitude from an audio analysis. This is also known as "envelope following" and we can use this analysis to control parameters in our patches. Another object we can use is [mov.avg~]. Here we use it to control the output level., f 53;
#X obj 366 423 sigmund~;
#X text 298 335 Another object that reports amplitude analysis like [env~] is [sigmund~] \, which we'll see next., f 20;
#X connect 0 0 3 0;
#X connect 4 0 5 0;
#X connect 4 0 6 0;
#X connect 4 0 8 0;
#X connect 5 0 0 0;
#X connect 6 0 1 0;
#X connect 7 0 11 0;
#X connect 8 0 7 1;
#X connect 8 0 9 0;
#X connect 10 0 7 0;

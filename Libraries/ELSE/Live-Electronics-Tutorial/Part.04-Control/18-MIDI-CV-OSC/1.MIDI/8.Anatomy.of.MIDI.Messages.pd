#N canvas 353 48 1013 513 12;
#X declare -path else;
#X obj 819 28 declare -path else;
#X text 531 170 Program Change and Aftertouch only need to be followed by one more value to represent \, respectively \, Program number and Aftertouch value. Let's check all of these in detail below., f 62;
#N canvas 619 54 626 579 Control-Change 0;
#X text 259 462 MIDI channel;
#X obj 236 459 display;
#X obj 188 489 display 3;
#X obj 141 520 display 2;
#X obj 141 431 ctl.in, f 14;
#X text 221 492 Control Number;
#X text 170 523 Control Value;
#X msg 141 303 176 \, 15 \, 77;
#X text 240 288 Control change in channel 1 \; Control Number (15) \; Control value (77), f 29;
#X text 54 32 Control Change messages are composed of 3 bytes., f 66;
#X text 54 53 They start with a first number from 176 to 191 that codifies the MIDI Channel (176 is channel 1 \, 177 is channel 2 and so on)., f 66;
#X text 54 89 The following two bytes represent \, respectively \, control number and control value (whose values are from 0 to 127)., f 66;
#X text 54 125 This gives us 127 different controllers in each channel to set parameters., f 66;
#X text 54 165 Usually \, in MIDI controllers \, control change values are given by sliders and knobs., f 66;
#X text 54 204 Pd Vanilla has a [ctlin] object and the ELSE library has [ctl.in] \, which retrieves control change messages from raw MIDI input., f 66;
#X msg 155 363 178 \, 15 \, 0;
#X text 240 349 Control change in channel 3 \; Control Number (15) \; Control value (0), f 29;
#X connect 4 0 3 0;
#X connect 4 1 2 0;
#X connect 4 2 1 0;
#X connect 7 0 4 0;
#X connect 15 0 4 0;
#X restore 616 289 pd Control-Change;
#N canvas 652 84 574 525 Program-Change 0;
#X text 216 447 MIDI channel;
#X obj 193 444 display;
#X obj 98 475 display 2;
#X text 127 478 Control Value;
#X text 53 32 Program Change messages are composed of 2 bytes., f 66;
#X text 53 113 Program Change values are usually for changing from one program (or "patch" in the Pd world) to another. So you can change timbres in a synth., f 66;
#X text 53 164 Pd Vanilla has a [pgmin] object and note that it outputs values from 1 to 128! The ELSE library has [pgm.in] \, which retrieves program change messages from raw MIDI input. The output is also "raw" in a sense that program number values are from 0 to 127!, f 66;
#X text 53 90 The following byte represents the program number (from 0 to 127)., f 66;
#X text 53 234 Unlike MIDI channels \, that have a standard of being numbered from 1 to 16 \, there's no official standard for Program Change messages \, but it's common to find it numbered from 1 to 128 as in Pd., f 66;
#X obj 98 416 pgm.in, f 14;
#X msg 98 318 192 \, 0;
#X text 151 321 Program change in channel 1 \, Program Value (0);
#X text 53 53 They start with a first number from 192 to 207 that codifies the MIDI Channel (192 is channel 1 \, 193 is channel 2 and so on)., f 66;
#X msg 112 368 199 \, 80;
#X text 175 368 Program change in channel 8 \, Program Value (80);
#X connect 9 0 2 0;
#X connect 9 1 1 0;
#X connect 10 0 9 0;
#X connect 13 0 9 0;
#X restore 757 287 pd Program-Change;
#N canvas 527 107 685 634 Pitch-Bend 0;
#X text 201 534 MIDI channel;
#X obj 178 531 display;
#X obj 97 503 bend.in -raw;
#X text 143 571 Pitch bend;
#X msg 97 342 224 \, 127 \, 127;
#X obj 97 567 display 5;
#X text 46 17 Pitch Bend messages are composed of 3 bytes., f 64;
#X text 46 35 They start with a first number from 224 to 239 that codifies the MIDI Channel (224 is channel 1 \, 225 is channel 2 and so on)., f 81;
#X msg 105 365 224 \, 127 \, 63;
#X text 203 342 Pitch Bend in channel 1 \, Bend values (127 \, 127);
#X text 203 366 Pitch Bend in channel 1 \, Bend values (127 \, 63);
#X msg 120 394 226 \, 97 \, 0;
#X text 203 395 Pitch Bend in channel 3 \, Bend values (97 \, 0);
#X msg 128 458 239 \, 0 \, 0;
#X text 203 459 Pitch Bend in channel 16 \, Bend values (0 \, 0);
#X text 46 272 The way to get the bend value is by summing the first byte value to the second byte value. But the second byte is multiplied by 128!, f 81;
#X msg 127 421 226 \, 0 \, 8;
#X text 46 71 The following two bytes (whose values are from 0 to 127) compose the pitch bend value. Since we have 2 values with 7 bit resolution \, the Pitch Bend messages have a 14 bit resolution (from 0 to 1383). This makes it really special in comparison to the other MIDI message types for its superior resolution., f 81;
#X text 46 141 MIDI controllers usually have a special "wheel like" controller for this. When not in motion \, the wheel sits in the middle and if you slide it forward you have a pitch bend upwards \, whereas it bends the pitch lower otherwise. When you release the wheel \, it gets back to the middle position., f 81;
#X text 46 207 Pd Vanilla has [bendin] and ELSE has [bend.in] (which retrieves pitch bend messages from raw MIDI input). The [bend.in] object outputs values from -1 to 1 \, but with the '-raw' flag \, the output of [bend.in] is from 0 to 16383 (so the mid point would be 8191)., f 81;
#X text 203 422 Pitch Bend in channel 3 \, Bend values (0 \, 8);
#X connect 2 0 5 0;
#X connect 2 1 1 0;
#X connect 4 0 2 0;
#X connect 8 0 2 0;
#X connect 11 0 2 0;
#X connect 13 0 2 0;
#X connect 16 0 2 0;
#X restore 758 327 pd Pitch-Bend;
#N canvas 296 158 1070 588 Note-On/Off 0;
#X text 63 88 Note On Messages start with a number from 144 (in channel 1) to 159 (channel 16)., f 66;
#X text 63 24 Note Off and Note On messages are composed of 3 bytes., f 66;
#X text 63 42 Note off messages start with a first number from 128 to 143 that codifies the MIDI Channel (129 is channel 1 \, 130 is channel 2 and so on)., f 66;
#X text 63 122 The following two bytes for note messages represent \, respectively \, Pitch and Velocity (whose values are from 0 to 127)., f 66;
#X text 63 164 In this tutorial section we've seen that Note Off messages are rare! Usually \, a Note On message with a velocity value of 0 represents a Note Off and this how Pd usually deals with it., f 66;
#X msg 70 348 144 \, 68 \, 120;
#X text 139 471 MIDI channel;
#X text 96 534 Pitch;
#X obj 116 468 display;
#X text 126 501 Velocity;
#X obj 70 440 note.in;
#X msg 94 404 128 \, 68 \, 120;
#X obj 93 498 display 3;
#X obj 70 529 display 2;
#X msg 84 371 144 \, 68 \, 0;
#X text 165 348 Note On in channel 1 \, Picth (68) \, Velocity (120);
#X text 165 371 Note On in channel 1 \, Picth (68) \, Velocity (120);
#X text 190 404 Note Off in channel 1 \, Picth (68) \, Velocity (120);
#X text 769 96 Note On (raw MIDI data);
#X text 784 142 Note Off (raw MIDI data);
#X obj 670 202 display;
#X obj 779 202 display;
#X obj 742 231 display;
#X text 607 205 pitch =>;
#X text 797 204 <== channel;
#X obj 670 173 note.in -rel, f 16;
#X text 762 233 <= flag (1 for Note On \, 0 for Note Off);
#X text 620 233 velocity =>;
#X obj 706 231 display 3;
#X text 588 24 With the '-rel' \, [note.in] can also retrieve the release velocity \, and it outputs a flag so you know you're dealing with a Note On or a Note Off message., f 61;
#X text 605 278 Even though you can rarely find a MIDI controller that outputs release velocity nowadays \, a MIDI file can easily contain this data and you can retrieve it in a patch., f 59;
#N canvas 631 232 735 493 release 0;
#X obj 89 49 inlet;
#X obj 89 91 note.in -rel, f 16;
#X obj 138 383 *~;
#X obj 125 125 list prepend;
#X obj 125 153 route 1 0, f 14;
#X obj 125 186 sel 0;
#X floatatom 157 260 5 0 0 0 - - - 0;
#X obj 89 260 mtof;
#X obj 89 288 osc~;
#X obj 157 327 adsr~ 20 10 0.5 10;
#X msg 125 214 0;
#X obj 280 263 rescale 10 1000;
#X msg 172 214 0;
#X obj 138 437 outlet~;
#X text 269 136 In this subpatch we route the Note On and Off messages in order that the Note On Velocity sets intensity and Note Off velocity sets the envelope's release time. A Note On message with velocity of zero is treated as a Note Off Message with a release velocity of 0 as well.;
#X connect 0 0 1 0;
#X connect 1 0 7 0;
#X connect 1 1 3 0;
#X connect 1 2 3 1;
#X connect 2 0 13 0;
#X connect 3 0 4 0;
#X connect 4 0 5 0;
#X connect 4 1 11 0;
#X connect 4 1 12 0;
#X connect 5 0 10 0;
#X connect 5 1 6 0;
#X connect 6 0 9 0;
#X connect 7 0 8 0;
#X connect 8 0 2 0;
#X connect 9 0 2 1;
#X connect 10 0 6 0;
#X connect 10 0 11 0;
#X connect 11 0 9 4;
#X connect 12 0 6 0;
#X restore 711 473 pd release;
#X obj 711 503 out~;
#X text 605 329 You can use the release velocity \, for instance \, to control the release phase of an envelope. Check the subpatch below.;
#X msg 726 409 144 \, 68 \, 0;
#X text 816 396 <= click;
#X text 833 442 <= click;
#X msg 670 88 144 \, 68 \, 120;
#X msg 684 109 144 \, 68 \, 0;
#X msg 698 142 128 \, 68 \, 88;
#X msg 740 441 128 \, 68 \, 127;
#X msg 712 385 144 \, 68 \, 127;
#X text 792 473 <= open;
#X text 64 214 This means that when [notein] receives a MIDI Note Off message with any velocity value (also known as "release velocity") \, Pd translates it to a Note On message with a velocity of 0! The same happens here below with the [note.in] object from the ELSE library. This object takes raw MIDI messages. Note that the output of [note.in] does not differentiate if it is a Note On or a Note Off message. And how a release velocity of 120 becomes a velocity of 0 to represent a Note Off message., f 66;
#X connect 5 0 10 0;
#X connect 10 0 13 0;
#X connect 10 1 12 0;
#X connect 10 2 8 0;
#X connect 11 0 10 0;
#X connect 14 0 10 0;
#X connect 25 0 20 0;
#X connect 25 1 28 0;
#X connect 25 2 22 0;
#X connect 25 3 21 0;
#X connect 31 0 32 0;
#X connect 34 0 31 0;
#X connect 37 0 25 0;
#X connect 38 0 25 0;
#X connect 39 0 25 0;
#X connect 40 0 31 0;
#X connect 41 0 31 0;
#X restore 637 247 pd Note-On/Off;
#N canvas 495 176 661 570 Polyphonic-Aftertouch 0;
#X text 215 444 MIDI channel;
#X obj 192 441 display;
#X obj 144 471 display 3;
#X obj 97 502 display 2;
#X text 46 17 Poliphonic Aftertouch messages are composed of 3 bytes., f 64;
#X text 46 35 They start with a first number from 160 to 175 that codifies the MIDI Channel (160 is channel 1 \, 161 is channel 2 and so on)., f 81;
#X text 46 71 The following two bytes represent \, respectively \, Pitch and Aftertouch (whose values are from 0 to 127)., f 81;
#X text 46 185 A simpler and more common version of aftertouch in current controllers is "channel aftertouch" \, where all keys of the keyboard will activate a single aftertouch parameter \, where the highest aftertouch in the channel prevails. But this is a separate message we'll also see here., f 81;
#X text 46 251 Pd Vanilla has two separate objects for both channel - [touchin] - and polyphonic aftertouch - [polytouch]. The ELSE library has a single object to deal with both message types: [touch.in]. With the "-poly" flag \, it retrieves key aftertouch messages from raw MIDI input., f 81;
#X obj 97 413 touch.in -poly;
#X msg 97 352 160 \, 127 \, 60;
#X msg 111 375 160 \, 0 \, 60;
#X text 177 474 Aftertouch;
#X text 192 352 Key Aftertouch in channel 1 \, Aftertouch (127) \, key (60);
#X text 192 375 Key Aftertouch in channel 1 \, Aftertouch (0) \, key (60);
#X text 126 505 Pitch (key);
#X text 46 107 Polyphonic (or "key") Aftertouch (or "pressure") is a control that became rare in modern controllers \, but it used to capture the pressure of each key after you played a note. This allows the synthesizer to add a specific modulation for each key voice. Nowadays the key aftertouch is more present in pad controllers., f 81;
#X connect 9 0 3 0;
#X connect 9 1 2 0;
#X connect 9 2 1 0;
#X connect 10 0 9 0;
#X connect 11 0 9 0;
#X restore 757 247 pd Polyphonic-Aftertouch;
#N canvas 507 233 670 423 Channel-Aftertouch 0;
#X text 237 326 MIDI channel;
#X obj 214 323 display;
#X text 46 15 Channel Aftertouch messages are composed of 2 bytes., f 64;
#X text 45 33 They start with a first number from 208 to 223 that codifies the MIDI Channel (208 is channel 1 \, 209 is channel 2 and so on)., f 81;
#X text 45 67 The following byte represents the Channel Aftertouch (from 0 to 127)., f 81;
#X text 45 91 As mentioned \, this is simpler version of Polyphnic Aftertouch that is more common in current controllers \, where all keys of the keyboard will activate a single aftertouch parameter for the whole channel \, where the highest aftertouch in the channel prevails., f 81;
#X obj 119 295 touch.in, f 14;
#X text 150 367 Aftertouch;
#X msg 119 234 208 \, 127;
#X text 194 234 Channel Aftertouch in channel 1 \, Aftertouch (127);
#X obj 119 364 display 3;
#X text 45 159 Pd Vanilla has [touchin] and ELSE has [touch.in] (that retrieves aftertouch messages from raw MIDI input). We also saw earlier that the same object can retrieve key aftertouch., f 81;
#X msg 133 257 219 \, 0;
#X text 194 257 Channel Aftertouch in channel 12 \, Aftertouch (0);
#X connect 6 0 10 0;
#X connect 6 1 1 0;
#X connect 8 0 6 0;
#X connect 12 0 6 0;
#X restore 588 327 pd Channel-Aftertouch;
#N canvas 329 156 951 470 System-messages 0;
#X text 83 94 240 - Start of sysex Messages, f 54;
#X text 83 111 241 - MIDI Time Code, f 54;
#X text 83 145 243 - Song Select, f 54;
#X text 83 180 246 - Tune Request. Upon receiving a Tune Request \, all analog synthesizers should tune their oscillators;
#X text 83 211 247 - End of sysex Messages, f 54;
#X text 83 162 244 & 245 - Undefined (reserved), f 54;
#X obj 795 119 sysexin;
#X text 29 21 Here's a table with the byte values and corresponding messages., f 35;
#X text 83 128 242 - Song Position Pointer, f 54;
#X text 63 72 System Common and System Exclusive Messages (240-247):;
#X text 65 244 System Real Time Messages (248-254);
#X text 83 276 248 - clock, f 26;
#X text 83 310 250 - start, f 26;
#X text 83 327 251 - continue, f 26;
#X text 83 344 252 - stop, f 26;
#X text 83 361 253 - undefined, f 26;
#X text 83 378 254 - Active Sensing, f 26;
#X text 83 395 255 - Reset, f 26;
#X text 83 293 249 - undefined (reserved);
#X text 521 15 Sysex messages allows a computer to communicate with external MIDI-compatible devices \, such as backing up patch data from a synthesizer to a computer's hard drive. Pd vanilla has [sysexin] to retrieve this sequence of bytes. Sysex messages start with 240 and end with 247 \, but can have any other values in between as a list of any length., f 53;
#X text 560 415 clock;
#X text 616 414 start;
#X text 666 414 continue;
#X text 733 414 stop;
#X text 785 415 active;
#X text 843 414 reset;
#X obj 570 229 midirealtimein;
#X obj 570 395 bng 15 250 50 0 empty empty empty 17 7 0 10 #dcdcdc #000000 #000000;
#X obj 626 395 bng 15 250 50 0 empty empty empty 17 7 0 10 #dcdcdc #000000 #000000;
#X obj 683 395 bng 15 250 50 0 empty empty empty 17 7 0 10 #dcdcdc #000000 #000000;
#X obj 740 395 bng 15 250 50 0 empty empty empty 17 7 0 10 #dcdcdc #000000 #000000;
#X obj 797 395 bng 15 250 50 0 empty empty empty 17 7 0 10 #dcdcdc #000000 #000000;
#X obj 854 395 bng 15 250 50 0 empty empty empty 17 7 0 10 #dcdcdc #000000 #000000;
#X text 783 427 sensing;
#X msg 584 260 248;
#X msg 617 260 250;
#X msg 622 289 251;
#X msg 655 289 252;
#X msg 662 318 254;
#X msg 699 318 255;
#X obj 570 362 sysrt.in, f 41;
#X text 522 153 The realtime messages are only retrieven in Pd by the [midirealtimein] object. The [sysrt.in] object from the ELSE library deals with them., f 53;
#X connect 26 0 40 0;
#X connect 34 0 40 0;
#X connect 35 0 40 0;
#X connect 36 0 40 0;
#X connect 37 0 40 0;
#X connect 38 0 40 0;
#X connect 39 0 40 0;
#X connect 40 0 27 0;
#X connect 40 1 28 0;
#X connect 40 2 29 0;
#X connect 40 3 30 0;
#X connect 40 4 31 0;
#X connect 40 5 32 0;
#X restore 725 451 pd System-messages;
#X text 26 15 MIDI messages are composed of a stream of byte messages. A byte is the same as 8 bits \, so this means that the possible values are 2ˆ8 (two to the power of 8). This gives us 256 possible values (from 0 to 255). Therefore \, MIDI messages is a sequence of numbers in the 0 to 255 range., f 67;
#X text 26 91 The main MIDI messages are: Control Change / Program Change / Channel Aftertouch / Polyphonic Aftertouch / Pitch Bend / Note On & Note Off. The values that correspond to these parameters (such as pitch and velocity) are within the range between 0 to 127! Thus \, they have a 7 bits resolution. The exception is pitch bend messages \, that uses 2 numbers from 0 to 127 to represent its value \, hence it has 14-bit resolution (from 0 to 16383)., f 67;
#X text 26 196 Here we'll see all of these messages in details \, and also others called "system messages" (such as Sysex and Real-time)., f 67;
#X text 26 232 For the cited main MIDI messages \, besides the value \, we also have a MIDI Channel. We have 16 possible MIDI Channels in the MIDI Protocol (which is usually a number from 1 to 16 by a standard)., f 67;
#X text 26 280 Values above 127 codify the MIDI message type and MIDI channel. For instance \, a number of 128 means we have a Note Off message for channel 1 \, 129 is "Note Off to channel 2: \, and so on until 143 (Note Off message to channel 16). The number 144 belongs to a new group of MIDI messages (Note on) \, and this is how they go. Below \, we have the different type of messages listed by value:, f 67;
#X text 531 60 Note On \, Note Off \, Poliphonic Aftertouch \, Control Change and Pitch Bend messages need to be followed by two more values. In Note On or Note Off \, these represent Pitch and Velocuty. For Polyphnic Aftertouch \, we need Pitch and Aftertouch value. For Control Change we have Control Number and Control Value. For Pitch Bend \, as stated before \, two values will codify a Pitch Bend value with 14-bits resolution., f 62;
#X text 532 380 We still have messages from 240 to 255 to deal with so called "System Messages". These are: "System Common Messages" \, "System Real Time Messages" and "System Exclusive Messages" (or "sysex"). Let's check them out:, f 65;
#X text 56 377 - 128 to 143: Note Off message in channels 1-16 \; - 144 to 159: Note On message in channels 1-16 \; - 160 to 175: Polyphonic Aftertouch in channels 1-16 \; - 176 to 191: Control Change messages in channels 1-16 \; - 192 to 207: Program Change messages in channels 1-16 \; - 208 to 223: Channel Aftertouch in channels 1-16 \; - 224 to 239: Pitch Bend messages in channels 1-16;

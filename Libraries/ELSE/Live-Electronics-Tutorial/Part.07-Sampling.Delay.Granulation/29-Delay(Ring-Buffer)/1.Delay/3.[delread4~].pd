#N canvas 581 23 494 723 12;
#X declare -path else;
#X obj 301 313 hsl 128 15 0 1000 0 0 empty empty empty -2 -8 0 10 #dcdcdc #000000 #000000 0 1;
#X floatatom 298 340 0 0 0 0 - - - 0;
#X text 54 626 BUG:;
#X obj 61 428 out~;
#X obj 298 463 out~;
#X msg 298 368 500 \$1;
#X obj 298 398 envgen~;
#X obj 298 430 delread4~ \$0-delay;
#X obj 84 394 delwrite~ \$0-delay 1000;
#X text 51 511 Interpolation:;
#X text 51 535 Since it uses the same interpolation as [tabread4~] \, the [delread4~] object also ignores the first recorded sample \, as it is supposed to be a guard point. In practical terms \, the object's minimum delay is 1 sample (whereas [delread~] can have a minimum delay of 0).;
#X obj 310 16 declare -path else;
#X obj 61 345 play.file~ bubul.wav 1 1, f 25;
#X text 34 144 A signal input allows a smooth and continuous change in the read position. Note however that such changes promote a speed change. Thinking again of a magnetic tape \, for the read head to move from one point to another \, its moving speed is sumed to the normal reading speed of the tape \, hence \, pitch changes!;
#X text 34 243 But when the read head reaches its destination and rests there \, only the reading speed of the tape is acting \, so the original speed is restored. Fool around with the slider below and see how that happens.;
#X text 55 651 Up to Pd 0.53-0 \, [delread~] and [delread4~] cannot read up to the maximum delay line if they have different block sizes. A workaround is to specify a buffer size a block longer than you actually need.;
#X text 34 48 The [delread~] object only has control input and does not interpolate \, so it can only read back in a buffer at a specific sample behind. On the other hand \, the native [delread4~] object can read in between samples with the same kind of interpolation used in [tabread4~] (lagrange) and accepts signal inputs., f 59;
#X connect 0 0 1 0;
#X connect 1 0 5 0;
#X connect 5 0 6 0;
#X connect 6 0 7 0;
#X connect 7 0 4 0;
#X connect 12 0 3 0;
#X connect 12 0 8 0;
